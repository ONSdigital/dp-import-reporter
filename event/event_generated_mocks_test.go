// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package event

import (
	"context"
	"github.com/ONSdigital/dp-import-reporter/model"
	"sync"
)

// Ensure, that DatasetAPICliMock does implement DatasetAPICli.
// If this is not the case, regenerate this file with moq.
var _ DatasetAPICli = &DatasetAPICliMock{}

// DatasetAPICliMock is a mock implementation of DatasetAPICli.
//
// 	func TestSomethingThatUsesDatasetAPICli(t *testing.T) {
//
// 		// make and configure a mocked DatasetAPICli
// 		mockedDatasetAPICli := &DatasetAPICliMock{
// 			AddEventToInstanceFunc: func(ctx context.Context, instanceID string, e *model.Event) error {
// 				panic("mock out the AddEventToInstance method")
// 			},
// 			GetInstanceFunc: func(ctx context.Context, instanceID string) (*model.Instance, error) {
// 				panic("mock out the GetInstance method")
// 			},
// 			UpdateInstanceStatusFunc: func(ctx context.Context, instanceID string, state *model.State) error {
// 				panic("mock out the UpdateInstanceStatus method")
// 			},
// 		}
//
// 		// use mockedDatasetAPICli in code that requires DatasetAPICli
// 		// and then make assertions.
//
// 	}
type DatasetAPICliMock struct {
	// AddEventToInstanceFunc mocks the AddEventToInstance method.
	AddEventToInstanceFunc func(ctx context.Context, instanceID string, e *model.Event) error

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(ctx context.Context, instanceID string) (*model.Instance, error)

	// UpdateInstanceStatusFunc mocks the UpdateInstanceStatus method.
	UpdateInstanceStatusFunc func(ctx context.Context, instanceID string, state *model.State) error

	// calls tracks calls to the methods.
	calls struct {
		// AddEventToInstance holds details about calls to the AddEventToInstance method.
		AddEventToInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// E is the e argument value.
			E *model.Event
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// UpdateInstanceStatus holds details about calls to the UpdateInstanceStatus method.
		UpdateInstanceStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// State is the state argument value.
			State *model.State
		}
	}
	lockAddEventToInstance   sync.RWMutex
	lockGetInstance          sync.RWMutex
	lockUpdateInstanceStatus sync.RWMutex
}

// AddEventToInstance calls AddEventToInstanceFunc.
func (mock *DatasetAPICliMock) AddEventToInstance(ctx context.Context, instanceID string, e *model.Event) error {
	if mock.AddEventToInstanceFunc == nil {
		panic("DatasetAPICliMock.AddEventToInstanceFunc: method is nil but DatasetAPICli.AddEventToInstance was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		E          *model.Event
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		E:          e,
	}
	mock.lockAddEventToInstance.Lock()
	mock.calls.AddEventToInstance = append(mock.calls.AddEventToInstance, callInfo)
	mock.lockAddEventToInstance.Unlock()
	return mock.AddEventToInstanceFunc(ctx, instanceID, e)
}

// AddEventToInstanceCalls gets all the calls that were made to AddEventToInstance.
// Check the length with:
//     len(mockedDatasetAPICli.AddEventToInstanceCalls())
func (mock *DatasetAPICliMock) AddEventToInstanceCalls() []struct {
	Ctx        context.Context
	InstanceID string
	E          *model.Event
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		E          *model.Event
	}
	mock.lockAddEventToInstance.RLock()
	calls = mock.calls.AddEventToInstance
	mock.lockAddEventToInstance.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *DatasetAPICliMock) GetInstance(ctx context.Context, instanceID string) (*model.Instance, error) {
	if mock.GetInstanceFunc == nil {
		panic("DatasetAPICliMock.GetInstanceFunc: method is nil but DatasetAPICli.GetInstance was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
	}
	mock.lockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	mock.lockGetInstance.Unlock()
	return mock.GetInstanceFunc(ctx, instanceID)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//     len(mockedDatasetAPICli.GetInstanceCalls())
func (mock *DatasetAPICliMock) GetInstanceCalls() []struct {
	Ctx        context.Context
	InstanceID string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
	}
	mock.lockGetInstance.RLock()
	calls = mock.calls.GetInstance
	mock.lockGetInstance.RUnlock()
	return calls
}

// UpdateInstanceStatus calls UpdateInstanceStatusFunc.
func (mock *DatasetAPICliMock) UpdateInstanceStatus(ctx context.Context, instanceID string, state *model.State) error {
	if mock.UpdateInstanceStatusFunc == nil {
		panic("DatasetAPICliMock.UpdateInstanceStatusFunc: method is nil but DatasetAPICli.UpdateInstanceStatus was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		State      *model.State
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		State:      state,
	}
	mock.lockUpdateInstanceStatus.Lock()
	mock.calls.UpdateInstanceStatus = append(mock.calls.UpdateInstanceStatus, callInfo)
	mock.lockUpdateInstanceStatus.Unlock()
	return mock.UpdateInstanceStatusFunc(ctx, instanceID, state)
}

// UpdateInstanceStatusCalls gets all the calls that were made to UpdateInstanceStatus.
// Check the length with:
//     len(mockedDatasetAPICli.UpdateInstanceStatusCalls())
func (mock *DatasetAPICliMock) UpdateInstanceStatusCalls() []struct {
	Ctx        context.Context
	InstanceID string
	State      *model.State
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		State      *model.State
	}
	mock.lockUpdateInstanceStatus.RLock()
	calls = mock.calls.UpdateInstanceStatus
	mock.lockUpdateInstanceStatus.RUnlock()
	return calls
}

// Ensure, that CacheMock does implement Cache.
// If this is not the case, regenerate this file with moq.
var _ Cache = &CacheMock{}

// CacheMock is a mock implementation of Cache.
//
// 	func TestSomethingThatUsesCache(t *testing.T) {
//
// 		// make and configure a mocked Cache
// 		mockedCache := &CacheMock{
// 			DelFunc: func(key []byte) bool {
// 				panic("mock out the Del method")
// 			},
// 			GetFunc: func(key []byte) ([]byte, error) {
// 				panic("mock out the Get method")
// 			},
// 			SetFunc: func(key []byte, value []byte, expireSeconds int) error {
// 				panic("mock out the Set method")
// 			},
// 			TTLFunc: func(key []byte) (uint32, error) {
// 				panic("mock out the TTL method")
// 			},
// 		}
//
// 		// use mockedCache in code that requires Cache
// 		// and then make assertions.
//
// 	}
type CacheMock struct {
	// DelFunc mocks the Del method.
	DelFunc func(key []byte) bool

	// GetFunc mocks the Get method.
	GetFunc func(key []byte) ([]byte, error)

	// SetFunc mocks the Set method.
	SetFunc func(key []byte, value []byte, expireSeconds int) error

	// TTLFunc mocks the TTL method.
	TTLFunc func(key []byte) (uint32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Del holds details about calls to the Del method.
		Del []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key []byte
			// Value is the value argument value.
			Value []byte
			// ExpireSeconds is the expireSeconds argument value.
			ExpireSeconds int
		}
		// TTL holds details about calls to the TTL method.
		TTL []struct {
			// Key is the key argument value.
			Key []byte
		}
	}
	lockDel sync.RWMutex
	lockGet sync.RWMutex
	lockSet sync.RWMutex
	lockTTL sync.RWMutex
}

// Del calls DelFunc.
func (mock *CacheMock) Del(key []byte) bool {
	if mock.DelFunc == nil {
		panic("CacheMock.DelFunc: method is nil but Cache.Del was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(key)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//     len(mockedCache.DelCalls())
func (mock *CacheMock) DelCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *CacheMock) Get(key []byte) ([]byte, error) {
	if mock.GetFunc == nil {
		panic("CacheMock.GetFunc: method is nil but Cache.Get was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedCache.GetCalls())
func (mock *CacheMock) GetCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *CacheMock) Set(key []byte, value []byte, expireSeconds int) error {
	if mock.SetFunc == nil {
		panic("CacheMock.SetFunc: method is nil but Cache.Set was just called")
	}
	callInfo := struct {
		Key           []byte
		Value         []byte
		ExpireSeconds int
	}{
		Key:           key,
		Value:         value,
		ExpireSeconds: expireSeconds,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(key, value, expireSeconds)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//     len(mockedCache.SetCalls())
func (mock *CacheMock) SetCalls() []struct {
	Key           []byte
	Value         []byte
	ExpireSeconds int
} {
	var calls []struct {
		Key           []byte
		Value         []byte
		ExpireSeconds int
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// TTL calls TTLFunc.
func (mock *CacheMock) TTL(key []byte) (uint32, error) {
	if mock.TTLFunc == nil {
		panic("CacheMock.TTLFunc: method is nil but Cache.TTL was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockTTL.Lock()
	mock.calls.TTL = append(mock.calls.TTL, callInfo)
	mock.lockTTL.Unlock()
	return mock.TTLFunc(key)
}

// TTLCalls gets all the calls that were made to TTL.
// Check the length with:
//     len(mockedCache.TTLCalls())
func (mock *CacheMock) TTLCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockTTL.RLock()
	calls = mock.calls.TTL
	mock.lockTTL.RUnlock()
	return calls
}

// Ensure, that EventHandlerMock does implement EventHandler.
// If this is not the case, regenerate this file with moq.
var _ EventHandler = &EventHandlerMock{}

// EventHandlerMock is a mock implementation of EventHandler.
//
// 	func TestSomethingThatUsesEventHandler(t *testing.T) {
//
// 		// make and configure a mocked EventHandler
// 		mockedEventHandler := &EventHandlerMock{
// 			HandleEventFunc: func(ctx context.Context, e *model.ReportEvent) error {
// 				panic("mock out the HandleEvent method")
// 			},
// 		}
//
// 		// use mockedEventHandler in code that requires EventHandler
// 		// and then make assertions.
//
// 	}
type EventHandlerMock struct {
	// HandleEventFunc mocks the HandleEvent method.
	HandleEventFunc func(ctx context.Context, e *model.ReportEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleEvent holds details about calls to the HandleEvent method.
		HandleEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// E is the e argument value.
			E *model.ReportEvent
		}
	}
	lockHandleEvent sync.RWMutex
}

// HandleEvent calls HandleEventFunc.
func (mock *EventHandlerMock) HandleEvent(ctx context.Context, e *model.ReportEvent) error {
	if mock.HandleEventFunc == nil {
		panic("EventHandlerMock.HandleEventFunc: method is nil but EventHandler.HandleEvent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		E   *model.ReportEvent
	}{
		Ctx: ctx,
		E:   e,
	}
	mock.lockHandleEvent.Lock()
	mock.calls.HandleEvent = append(mock.calls.HandleEvent, callInfo)
	mock.lockHandleEvent.Unlock()
	return mock.HandleEventFunc(ctx, e)
}

// HandleEventCalls gets all the calls that were made to HandleEvent.
// Check the length with:
//     len(mockedEventHandler.HandleEventCalls())
func (mock *EventHandlerMock) HandleEventCalls() []struct {
	Ctx context.Context
	E   *model.ReportEvent
} {
	var calls []struct {
		Ctx context.Context
		E   *model.ReportEvent
	}
	mock.lockHandleEvent.RLock()
	calls = mock.calls.HandleEvent
	mock.lockHandleEvent.RUnlock()
	return calls
}
